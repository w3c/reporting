<h1>Reporting API</h1>
<pre class="metadata">
Status: CG-DRAFT
ED: https://wicg.github.io/reporting/
Shortname: reporting
Group: wicg
Editor: Douglas Creager 103120, Google Inc., dcreager@google.com
Editor: Ilya Grigorik 56102, Google Inc., igrigorik@google.comm
Editor: Mike West 56384, Google Inc., mkwst@google.com
Abstract:
  This document defines a generic reporting framework which allows web
  developers to associate a set of named reporting endpoints with an origin.
  Various platform features (like Content Security Policy, Network Error
  Reporting, and others) will use these endpoints to deliver feature-specific
  reports in a consistent manner.
Level: 1
Indent: 2
Version History: https://github.com/wicg/reporting/commits/master/index.src.html
Boilerplate: omit conformance, omit feedback-header
!Participate: <a href="https://github.com/wicg/reporting/issues/new">File an issue</a> (<a href="https://github.com/wicg/reporting/issues">open issues</a>)
Markup Shorthands: css off, markdown on
</pre>
<pre class="anchors">
spec: CSP; urlPrefix: https://w3c.github.io/webappsec-csp/
  type: dfn
    text: Content-Security-Policy
    text: reports directive; url: directives-reporting
spec: ECMA-262; urlPrefix: http://www.ecma-international.org/ecma-262/6.0/
  type: method
    text: JSON.stringify(); url: sec-json.stringify
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: navigation request
    text: response; url: concept-response
    text: request; url: concept-request
    text: header; url: concept-header
    text: header list; url: concept-header-list
    text: main fetch
    text: fetch; url: concept-fetch
    text: wait for a response
    text: ok status
  type: attribute
    for: response
      text: url; url: concept-response-url
      text: HTTPS state; url: concept-response-https-state
      text: header list; url: concept-response-header-list
    for: request
      text: target browsing context; url: concept-request-target-browsing-context
    for: header
      text: name; url: concept-header-name
      text: value; url: concept-header-value
spec: SECURE-CONTEXTS; urlPrefix: https://w3c.github.io/webappsec-secure-contexts/
  type: dfn
    text: potentially trustworthy; url: is-origin-trustworthy
spec: URL; urlPrefix: https://url.spec.whatwg.org/
  type: dfn
    text: origin of a url; url: concept-url-origin
    text: URL serializer; url: concept-url-serializer
    text: URL parser; url: concept-url-parser
  type: interface
    text: URL; url: concept-url
  type: attribute
    for: URL
      text: username; url: concept-url-username
      text: password; url: concept-url-password
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/
  urlPrefix: infrastructure.html
    type: dfn
      text: ASCII case-insensitive
  urlPrefix: webappapis.html
    type: dfn
      text: global object
      text: environment settings object
      text: creation URL
      text: queue a task
  urlPrefix: browsers.html
    type: dfn
      text: origin
      text: top-level browsing context
spec: RFC3986; urlPrefix: https://tools.ietf.org/html/rfc3986
  type: grammar
    text: absolute-uri; url: section-4.3
spec: RFC6797; urlPrefix: https://tools.ietf.org/html/rfc6797
  type: dfn
    url: section-8.2
      text: superdomain match
      text: congruent match
spec: RFC7159; urlPrefix: https://tools.ietf.org/html/rfc7159
  type: dfn
    text: JSON text; url: section-2
spec: RFC7230; urlPrefix: https://tools.ietf.org/html/rfc7230
  type: grammar
    text: OWS; url: section-3.2.3
    text: BWS; url: section-3.2.3
    text: token; url: section-3.2.6
    text: quoted-string; url: section-3.2.6
    text: #rule; url: section-7
spec: RFC7234; urlPrefix: https://tools.ietf.org/html/rfc7234
  type: grammar
    text: delta-seconds; url: section-1.2.1
spec: RFC7469; urlPrefix: https://tools.ietf.org/html/rfc7469
  type: dfn
    text: Public-Key-Pins; url: section-2.1

spec: HTTP-JFV; urlPrefix: https://greenbytes.de/tech/webdav/draft-reschke-http-jfv-02.html
  type: grammar
    text: json-field-value; url: rfc.section.2

spec: ECMASCRIPT; urlPrefix: https://tc39.github.io/ecma262/
  type: dfn
    text: Realm
</pre>
<pre class="biblio">
{
  "SECURE-CONTEXTS": {
    "authors": [ "Mike West", "Yan Zhu" ],
    "href": "https://w3c.github.io/webappsec-secure-contexts/",
    "title": "Secure Contexts",
    "publisher": "W3C"
  },
  "HTTP-JFV": {
    "authors": [ "Julian Reschke" ],
    "href": "https://greenbytes.de/tech/webdav/draft-reschke-http-jfv-02.html",
    "title": "A JSON Encoding for HTTP Header Field Values"
  }
}

</pre>
<section>
  <h2 id="intro">Introduction</h2>

  [INTRODUCTION GOES HERE]

  <h3 id="guarantees">Guarantees</h3>

  This specification aims to provide a best-effort report delivery system that
  executes out-of-band with website activity. The user agent will be able to do
  a better job prioritizing and scheduling delivery of reports, as it has an
  overview of cross-origin activity that individual websites do not, and can
  deliver reports based on error conditions that would prevent a website from
  loading in the first place.

  The delivery is not, however, guaranteed in a strict sense. We spell out a
  reasonable set of retry rules in the algorithms below, but it's quite possible
  for a report to be dropped on the floor if things go badly. Also, the user
  agent MAY choose to prevent delivery of specific reports.

  Reporting can generate a good deal of traffic, so we allow developers to set
  up groups of <a>endpoints</a> in order to distribute load. Each of these
  endpoints will receive a subset of the generated reports which target that
  group. The user agent will do its best to deliver a particular report to
  <strong>at most one</strong> endpoint in a group. That is, reports will not
  fan-out to all the endpoints in a group, but the user agent will attempt
  delivery to one endpoint, and fallback to another upon failure.

  <h3 id="examples">Examples</h3>

  <div class="example">
    MegaCorp Inc. wants to collect Content Security Policy and Key Pinning
    violation reports. It can do so by delivering the following header to
    define a set of reporting endpoints named "`endpoint-1`":

    <pre>
      <a>Report-To</a>: { "<a for="ReportTo">group</a>": "endpoint-1",
                   "<a for="ReportTo">max-age</a>": 10886400,
                   "<a>endpoints</a>": [
                     { "<a for="ReportTo">url</a>": "https://example.com/reports" },
                     { "<a for="ReportTo">url</a>": "https://backup.com/reports" }
                   ] }
    </pre>

    And the following headers, which direct CSP and HPKP reports to that group:

    <pre>
      <a>Content-Security-Policy</a>: ...; <a lt="reports directive">report-to</a>=endpoint-1
      <a>Public-Key-Pins</a>: ...; report-to=endpoint-1
    </pre>
  </div>

  <div class="example">
    After processing reports for a little while, MegaCorp Inc. decides to split
    the processing of these two types of reports out into two distinct endpoints
    in order to make the processing scripts simpler. It can do so by delivering
    the following header to define two reporting endpoints:

    <pre>
      <a>Report-To</a>: { "<a for="ReportTo">url</a>": "https://example.com/csp-reports",
                   "<a for="ReportTo">group</a>": "csp-endpoint",
                   "<a for="ReportTo">max-age</a>": 10886400 },
                 { "<a for="ReportTo">url</a>": "https://example.com/hpkp-reports",
                   "<a for="ReportTo">group</a>": "hpkp-endpoint",
                   "<a for="ReportTo">max-age</a>": 10886400 }
      <a>Report-To</a>: { "<a for="ReportTo">group</a>": "csp-endpoint",
                   "<a for="ReportTo">max-age</a>": 10886400,
                   "<a for="ReportTo">endpoints</a>": [
                     { "<a for="ReportTo">url</a>": "https://example.com/csp-reports" }
                   ] },
                 { "<a for="ReportTo">group</a>": "hpkp-endpoint",
                   "<a for="ReportTo">max-age</a>": 10886400,
                   "<a for="ReportTo">endpoints</a>": [
                     { "<a for="ReportTo">url</a>": "https://example.com/hpkp-reports" }
                   ] }
    </pre>

    And the following headers, which direct CSP and HPKP reports to those named
    endpoint:

    <pre>
      <a>Content-Security-Policy</a>: ...; <a lt="reports directive">report-to</a>=csp-endpoint
      <a>Public-Key-Pins</a>: ...; report-to=hpkp-endpoint
    </pre>
  </div>
</section>

<section>
  <h2 id="concept">Concepts</h2>

  <h3 id="concept-client">Clients</h3>

  A <dfn export>client</dfn> represents a particular origin's relationship to
  a set of <a>endpoints</a>.

  Each <a>client</a> has an <dfn for="client" export attribute>origin</dfn>,
  which is an <a spec="html">origin</a>.

  Each <a>client</a> has an
  <dfn for="client" export attribute>endpoint-groups</dfn> list, which is a list
  of <a>endpoint groups</a>, each of which MUST have a distinct
  {{endpoint group/name}}.  (The algorithm in [[#process-header]] guarantees
  this by keeping the first entry in a `Report-To` header with a particular
  name.)

  <h3 id="concept-endpoint-groups">Endpoint groups</h3>

  An <dfn export>endpoint group</dfn> is a set of <a>endpoints</a> that will be
  used together for backup and failover purposes.

  Each <a>endpoint group</a> has a
  <dfn for="endpoint group" export attribute>name</dfn>, which is an ASCII
  string.

  Each <a>endpoint group</a> has an
  <dfn for="endpoint group" export attribute>endpoints</dfn> list, which is a
  list of <a>endpoints</a>.

  Each <a>endpoint group</a> has a
  <dfn for="endpoint group" export attribute>subdomains</dfn> flag, which is
  either "`include`" or "`exclude`".

  Each <a>endpoint group</a> has a
  <dfn for="endpoint group" export attribute>ttl</dfn> representing the
  number of seconds the group remains valid for an <a spec="html">origin</a>.

  Each <a>endpoint group</a> has a
  <dfn for="endpoint group" export attribute>creation</dfn> which is the
  timestamp at which the group was added to an <a spec="html">origin</a>.

  An <a>endpoint group</a> is
  <dfn for="endpoint group" id="endpoint-group-expired">expired</dfn> if its
  {{endpoint group/creation}} plus its {{endpoint group/ttl}} represents a time
  in the past.

  <h3 id="concept-endpoints">Endpoints</h3>

  An <dfn export>endpoint</dfn> is location to which <a>reports</a> for a
  particular <a spec="html">origin</a> may be sent.

  Each <a>endpoint</a> has a <dfn for="endpoint" export attribute>url</dfn>,
  which is a {{URL}}.

  Each <a>endpoint</a> has a
  <dfn for="endpoint" export attribute>failures</dfn>, which is a non-negative
  integer representing the number of consecutive times this endpoint has failed
  to respond to a request.

  Each <a>endpoint</a> has a
  <dfn for="endpoint" export attribute>retry-after</dfn>, which is either
  `null`, or a timestamp after which delivery should be retried.

  An <a>endpoint</a> is <dfn for="endpoint">pending</dfn> if its
  {{endpoint/retry-after}} is not `null`, and represents a time in the future.

  <h3 id="concept-report-type">Report Type</h3>

  A <dfn>report type</dfn> is a non-empty string that specifies the set of data
  that is contained in the [=report/body=] of a <a>report</a>.

  When a <a>report type</a> is defined (in this spec or others), it can be
  specified to be <dfn>observable from JavaScript</dfn>, meaning
  that <a>reports</a> of that type can be observed by a <a>reporting
  observer</a>. By default, <a>report types</a> are not <a>observable from
  JavaScript</a>.

  A <a>report type</a> may have an associated <dfn>aggregated type</dfn>, which
  is itself a <a>report type</a> with the following properties:

  1.  A <a>report type</a>'s <a>aggregated type</a>'s <a>report</a> [=report/body=]
      will contain a subset of the fields in the original <a>report type</a>'s
      <a>report</a> [=report/body=], plus an additional "count" field.
  2.  An <a>aggregated type</a>'s <a>report</a> [=report/body=] must contain a
      "count" field.
  3.  An <a>aggregated type</a> is never <a>observable from JavaScript</a>.
  4.  An <a>aggregated type</a> does not have its own <a>aggregated type</a>.

  Note: See [[#deprecation-report]] as an example <a>report type</a> definition.

  <h3 id="concept-reports">Reports</h3>

  A <dfn export>report</dfn> is a collection of arbitrary data which the user
  agent is expected to deliver to a specified endpoint.

  Each <a>report</a> has a <dfn for="report" export>body</dfn>, which is either
  `null` or an object which can be serialized into a <a>JSON text</a>. The
  fields contained in a <a>report</a>'s [=report/body=] are determined by
  the <a>report</a>'s [=report/type=].

  Each <a>report</a> has a <dfn for="report" export>url</dfn>, which
  is the address of the `Document` or `Worker` from which the report was
  generated.

  Note: We strip the username, password, and fragment from this serialized URL.
  See [[#capability-urls]].

  Each <a>report</a> has an <dfn for="report" export>origin</dfn>,
  which is an <a spec="html">origin</a> representing the report's initiator.

  Each <a>report</a> has a <dfn for="report" export>group</dfn>,
  which is a string representing the {{endpoint group/name}} of the
  <a spec="html">origin</a>'s <a>endpoint group</a> that the report will be sent to.

  Each <a>report</a> has a <dfn for="report" export>type</dfn>, which is
  a <a>report type</a>.

  Each <a>report</a> has a <dfn for="report" export>timestamp</dfn>,
  which records the time at which the report was generated, in milliseconds
  since the unix epoch.

  Each <a>report</a> has an <dfn for="report" export>attempts</dfn>
  counter, which is a non-negative integer representing the number of times the
  user agent attempted to deliver the report.

  <h3 id="concept-storage">Storage</h3>

  A conformant user agent MUST provide a <dfn>reporting cache</dfn>, which
  is a storage mechanism that maintains a set of <a>endpoint groups</a> that
  websites have instructed the user agent to associate with their
  <a spec="html">origins</a>, and a set of <a>reports</a> which are queued for
  delivery.

  This storage mechanism is opaque, vendor-specific, and not exposed to the
  web, but it MUST provide the following methods which will be used in the
  algorithms this document defines:

  1.  Insert, update, and remove <a>clients</a>.
  2.  Enqueue and dequeue <a>reports</a> for delivery.
  3.  Retrieve a list of <a>client</a> objects for an <a spec="html">origin</a>.
  4.  Retrieve a list of queued <a>report</a> objects.
  5.  Clear the cache.
</section>

<section>
  <h2 id="endpoint-delivery">Endpoint Delivery</h2>

  A server MAY define a set of reporting endpoints for an origin it controls
  via the <a>`Report-To`</a> HTTP response header field. This mechanism
  is defined in [[#header]], and its processing in [[#process-header]].

  <h3 id="header">The `Report-To` HTTP Response Header Field</h3>

  The <dfn export>`Report-To`</dfn> HTTP response header field instructs the
  user agent to store reporting endpoints for an origin. The header is
  represented by the following ABNF grammar [[!RFC5234]]:

  <pre class="abnf" link-type="grammar" dfn-type="grammar">
    Report-To = <a>json-field-value</a>
                ; See Section 2 of [[HTTP-JFV]], and Section 2 of [[RFC7159]]
  </pre>

  The header's value is interpreted as an array of JSON objects, as described in
  Section 4 of [[HTTP-JFV]].

  Each object in the array defines an <a>endpoint group</a> to which reports may
  be delivered, and will be parsed as defined in [[#process-header]].

  The following subsections define the initial set of known members in each
  JSON object the header's value defines. Future versions of this document may
  define additional such members, and user agents MUST ignore unknown members
  when parsing the header.

  <h4 id="id-member">The `group` member</h4>

  The OPTIONAL <dfn for="ReportTo">`group`</dfn> member is a string that associates a
  {{endpoint group/name}} with the <a>endpoint group</a>. The member's value
  MUST be a string; any other type will result in a parse error. If no member
  named "`group`" is present in the object, the <a>endpoint group</a> will be
  given the {{endpoint group/name}} "`default`".

  <h4 id="include-subdomains-member">The `include-subdomains` member</h4>

  The OPTIONAL <dfn>`include-subdomains`</dfn> member is a boolean that enables
  this <a>endpoint group</a> for all subdomains of the
  current <a spec="html">origin</a>'s {{URL/host}}.  If no member named
  "`include-subdomains`" is present in the object, or its value is not "`true`",
  the <a>endpoint group</a> will not be enabled for subdomains.

  <h4 id="max-age-member">The `max-age` member</h4>

  The REQUIRED <dfn for="ReportTo" export>`max-age`</dfn> member defines the <a>endpoint
  group</a>'s lifetime, as a non-negative integer number of seconds. The
  member's value MUST be a non-negative number; any other type will result in a
  parse error.

  A value of "`0`" will cause the <a>endpoint group</a> to be removed from the
  user agent's <a>reporting cache</a>.

  <h4 id="endpoints-member">The `endpoints` member</h4>

  The REQUIRED <dfn for="ReportTo" export>`endpoints`</dfn> member defines the list of
  <a>endpoints</a> that belong to this <a>endpoint group</a>. The member's value
  MUST be an array of JSON objects.

  The following subsections define the initial set of known members in each
  JSON object in the array. Future versions of this document may define
  additional such members, and user agents MUST ignore unknown members when
  parsing the elements of the array.

  <!--
  Note: If a group resolves to multiple <a>endpoints</a>, the user agent will
  deliver a particular <a>report</a> to <strong>at most one</strong>
  <a>endpoint</a> in that group on a best-effort basis.
  -->

  <h4 id="endpoints-url-member">The `endpoints.url` member</h4>

  The REQUIRED <dfn for="ReportTo">`url`</dfn> member is a string that defines the location
  of the <a>endpoint</a>. The member's value MUST be a string; any other type
  will result in a parse error.

  Moreover, the URL that the member's value represents MUST be <a>potentially
  trustworthy</a> [[!SECURE-CONTEXTS]]. Non-secure endpoints will be ignored.

  <h3 id="process-header" algorithm>
    Process reporting endpoints for |response| to |request|
  </h3>

  Given a <a>response</a> (|response|) and a <a>request</a> (|request|), this
  algorithm extracts a list of <a>endpoints</a> and <a>endpoint groups</a> for
  the request's <a spec="html">origin</a>, and updates the <a>reporting cache</a>
  accordingly.

  Note: This algorithm is called from around step 13 of <a>main fetch</a>
  [[FETCH]], and only updates the <a>reporting cache</a> if the |response|
  has been delivered securely.

  ISSUE: Fetch monkey patching. Talk to Anne.

  1.  Abort these steps if any of the following conditions are true:

      1.  |response|'s <a for="response" attribute>HTTPS state</a> is not
          "`modern`", and the <a lt="origin of a url">origin</a> of |response|'s
          <a for="response" attribute>url</a> is not <a>potentially
          trustworthy</a>.

      2.  |response|'s <a for="response" attribute>header list</a> does not
          contain a <a>header</a> whose <a for="header" attribute>name</a> is
          "<a>`Report-To`</a>".

  2.  Let |origin| be the <a lt="origin of a url">origin</a> of |response|'s
      <a for="response" attribute>url</a>.

  3.  Let |header| be the <a for="header" attribute>value</a> of the
      <a>header</a> in |response|'s <a for="response" attribute>header list</a>
      whose name is "<a>`Report-To`</a>".

  4.  Let |list| be the result of executing the algorithm defined in Section 4
      of [[HTTP-JFV]] on |header|. If that algorithm results in an error, abort
      these steps.

  5.  Let |groups| be an empty list.

  6.  For each |item| in |list|:

      1.  If |item| has no member named "<a for="ReportTo">`max-age`</a>", or that member's
          value is not a number, skip to the next |item|.

      2.  If |item| has no member named "<a>`endpoints`</a>", or that member's
          value is not an array, skip to the next |item|.

      3.  Let |name| be |item|'s "<a for="ReportTo">`group`</a>" member's value if present, and
          "`default`" otherwise.

      4.  If there is already an <a>endpoint group</a> in |groups| whose
          {{endpoint group/name}} is |name|, skip to the next |item|.

      5.  Let |endpoints| be an empty list.

      6.  For each |endpoint item| in the value of |item|'s "<a for="ReportTo">`endpoints`</a>"
          member:

          1.  If |endpoint item| has no member named "<a for="ReportTo">`url`</a>", or that
              member's value is not a string, skip to the next |endpoint item|.

          2.  Let |endpoint| be a new <a>endpoint</a> whose properties are set
              as follows:

              :   {{endpoint/url}}
              ::  The result of executing the <a>URL parser</a> on
                  |endpoint item|'s "<a for="ReportTo">`url`</a>" member's value.
              :   {{endpoint/failures}}
              ::  0
              :   {{endpoint/retry-after}}
              ::  `null`

          3.  Add |endpoint| to |endpoints|.

      7.  Let |group| be a new <a>endpoint group</a> whose properties are
          set as follows:

          :   {{endpoint group/name}}
          ::  |name|
          :   {{endpoint group/subdomains}}
          ::  "`include`" if |item| has a member named
              "<a>`include-subdomains`</a>" whose value is `true`, "`exclude`"
              otherwise.
          :   {{endpoint group/ttl}}
          ::  |item|'s "<a for="ReportTo">`max-age`</a>" member's value.
          :   {{endpoint group/creation}}
          ::  The current timestamp
          :   {{endpoint group/endpoints}}
          ::  |endpoints|

      8.  Add |group| to |groups|.

  7.  Let |client| be a new <a>client</a> whose properties are set as follows:

      :   {{client/origin}}
      ::  |origin|
      :   {{client/endpoint-groups}}
      ::  |groups|

  8.  If there is already an entry in the <a>reporting cache</a> for
      <a spec="html">origin</a>, replace it with |client|.  Otherwise, insert
      |client| into the <a>reporting cache</a> for <a spec="html">origin</a>.


<!-- Big Text: Reporting -->
<section>
  <h2 id="report-delivery">Report Delivery</h2>

  Over time, various features will queue up a list of <a>reports</a> in the
  user agent's <a>reporting cache</a>. The user agent will periodically grab
  the list of currently pending reports, and deliver them to the associated
  endpoints. This document does not define a schedule for the user agent to
  follow, and assumes that the user agent will have enough contextual
  information to deliver reports in a timely manner, balanced against impacting
  a user's experience.

  That said, a user agent SHOULD make a effort to deliver reports as soon as
  possible after queuing, as a report's data might be significantly more useful
  in the period directly after its generation than it would be a day or a week
  later.

  <h3 id="queue-report" algorithm>
    Queue |data| as |type| for |endpoint group| on |settings|
  </h3>

  Given a serializable object (|data|), a string (|type|), another string
  (|endpoint group|), and an <a>environment settings object</a> (|settings|),
  the following algorithm will create a <a>report</a>, and add it to
  <a>reporting cache</a>'s queue for future delivery.

  1.  Let |report| be a new <a>report</a> object with its values initialized as
      follows:

      :   [=report/body=]
      ::  |data|
      :   [=report/origin=]
      ::  |settings|'s <a spec="html">origin</a>
      :   [=report/group=]
      ::  |endpoint group|
      :   [=report/type=]
      ::  |type|
      :   [=report/timestamp=]
      ::  The current timestamp.
      :   [=report/attempts=]
      ::  0

  2.  Let |url| be |settings|'s <a>creation URL</a>.

  3.  Set |url|'s {{URL/username}} to the empty string, and its {{URL/password}}
      to `null`.

  4.  Set |report|'s [=report/url=] to the result of executing the <a>URL
      serializer</a> on |url| with the <em>exclude fragment flag</em> set.

  5.  Append |report| to the <a>reporting cache</a>.

  6.  The user agent MAY choose to hide |report| from JavaScript (for example,
      for privacy or security reasons). If so, return.

  7.  Let |environment| be |settings|'s <a>realm execution context</a>'s
      <a spec=ecmascript>realm</a>'s <a spec=ecmascript lt=realm>ECMAScript global environment</a>.

  8.  Execute [[#notify-observers]] with |environment| and |report|.

  Note: <a>reporting observers</a> can only observe reports from the
  same <a>environment settings object</a>.

  Note: We strip the username, password, and fragment from the serialized URL
  in the report. See [[#capability-urls]].

  Note: The user agent MAY reject reports for any reason. This API does not
  guarantee delivery of arbitrary amounts of data, for instance.

  Note: Non user agent clients (with no JavaScript engine) should not interact
  with <a>reporting observers</a>, and thus should return in step 6.

  <h3 id="choose-endpoint">
    Choose an |endpoint| from a |group|
  </h3>

  Given an <a>endpoint group</a> (|group|), this algorithm chooses an arbitrary
  eligible <a>endpoint</a> from the group, if there is one.

  1.  If |group| is <a for="endpoint group">expired</a>, return `null`.

      Note: In this case, the user agent MAY remove |group| from its
      <a>client</a>, or it may wait and collect garbage <i lang="fr">en
      masse</i> at some point in the future as described in [[#gc]].

  2.  Return the first |endpoint| in |group|'s {{endpoint group/endpoints}} that
      is not <a for="endpoint">pending</a>.

      Note: This ensures that each report is assigned to a single endpoint in
      the specified group. In order to ensure an even distribution across
      endpoints, the user agent SHOULD randomize the order in which it walks
      through endpoints in the group.

  3.  If there are no <a>endpoints</a> in |group| that aren't
      <a for="endpoint">pending</a>, return `null`.

  <h3 id="send-reports" algorithm>
    Send reports
  </h3>

  A user agent sends reports by executing the following steps:

  1.  Let |reports| be a copy of the list of queued <a>report</a> objects in
      <a>reporting cache</a>.

  2.  Let |endpoint map| be an empty map of <a>endpoint</a> objects to lists of
      <a>report</a> objects.

  3.  For each |report| in |reports|:

      1.  Let |origin| be |report|'s [=report/origin=].

      2.  Let |client| be the entry in the <a>reporting cache</a> for
          |origin|.

      3.  If there exists an <a>endpoint group</a> (|group|) in |client|'s
          {{client/endpoint-groups}} list whose {{endpoint group/name}} is
          |report|'s [=report/group=]:

          1.  Let |endpoint| be the result of executing [[#choose-endpoint]] on
              |group|.

          2.  If |endpoint| is a not `null`:

              1.  Append |report| to |endpoint map|'s list of reports for
                  |endpoint|.

              2.  Skip to the next |report|.

      4.  For each |parent origin| that is a <a>superdomain match</a>
          for |origin| [[!RFC6797]]:

          1.  Let |client| be the entry in the <a>reporting cache</a> for
              |parent origin|.

          2.  If there exists an <a>endpoint group</a> (|group|) in |client|'s
              {{client/endpoint-groups}} list whose {{endpoint group/name}} is
              |report|'s [=report/group=] <b>and</b> whose {{endpoint
              group/subdomains}} flag is "`include`":

              1.  Let |endpoint| be the result of executing [[#choose-endpoint]]
                  on |group|.

              2.  If |endpoint| is an <a>endpoint</a>:

                  1.  Append |report| to |endpoint map|'s list of reports for
                      |endpoint|.

                  2.  Skip to the next |report|.

      5.  If we reach this step, the |report| did not match any <a>endpoint</a>
          and the user agent MAY remove |report| from the <a>reporting cache</a>
          directly. Depending on load, the user agent MAY instead wait for
          [[#gc]] at some point in the future.

  4.  For each (|endpoint|, |reports|) pair in |endpoint map|, execute the
      following steps asynchronously:

      1.  Let |result| be the result of executing [[#try-delivery]] on
          |endpoint| and |reports|.

      2.  If |result| is "`Success`":

          1.  Set |endpoint|'s {{endpoint/failures}} to 0, and its
              {{endpoint/retry-after}} to `null`.

          2.  Remove each <a>report</a> in |reports| from the <a>reporting
              cache</a>.

          Otherwise, if |result| is "`Remove Endpoint`":

          1.  Remove |endpoint| from the reporting cache.

              Note: |reports| remain in the reporting cache for potential
              delivery to other endpoints.

          Otherwise (if |result| is "`Failure`"):

          1.  Increment |endpoint|'s {{endpoint/failures}}.

          2.  Set |endpoint|'s {{endpoint/retry-after}} to a point in the future
              which the user agent chooses.

              Note: We don't specify a particular algorithm here, but user
              agents are encouraged to employ some sort of exponential backoff
              algorithm which increases the retry period with the number of
              failures, with the addition of some random jitter to ensure that
              temporary failures don't lead to a crush of reports all being
              retried on the same schedule.

              ISSUE: Add in a reasonable reference describing a good algorithm.
              Wikipedia, if nothing else.

  Note: User agents MAY decide to attempt delivery for only a subset of the
  collected reports or endpoints (because, for example, sending all the reports
  at once would consume an unreasonable amount of bandwidth, etc). As reports
  are only removed from the cache when they're successfully delivered, skipped
  reports will simply be delivered later.

  Note: For reports in the cache with <a>report types</a> that have
  associated <a>aggregated types</a>, endpoints may receive aggregated reports
  (reports with the <a>aggregated type</a>) in place of these original
  reports. Reports may be aggregated in this way for privacy or security
  reasons.

  <h3 id="try-delivery" algorithm>
    Attempt to deliver |reports| to |endpoint|
  </h3>

  Given a list of <a>reports</a> (|reports|) and an <a>endpoint</a>
  (|endpoint|), this algorithm will construct a <a>request</a>, and attempt to
  deliver it to |endpoint|. It returns "`Success`" if that delivery succeeds,
  "`Remove Endpoint`" if the endpoint explicitly removes itself as a reporting
  endpoint by sending a 410 response, and "`Failure`" otherwise.

  1.  Let |collection| be a new ECMAScript `Array` object [[!ECMA-262]].

  2.  For each |report| in |reports|:

      1.  Let |data| be a new ECMAScript `Object` with the following properties
          [[!ECMA-262]]:

          :   `age`
          ::  The number of milliseconds between |report|'s [=report/timestamp=]
              and the current time.
          :   `type`
          ::  |report|'s [=report/type=]
          :   `url`
          ::  |report|'s [=report/url=]
          :   `body`
          ::  |report|'s [=report/body=]

          Note: Client clocks are unreliable and subject to skew. We therefore
          deliver an `age` attribute rather than an absolute timestamp. See
          also [[#fingerprinting-clock-skew]]

      2.  Increment |report|'s [=report/attempts=].

      3.  Append |data| to |collection|.

  3.  Let |request| be a new <a>request</a> with the following properties
      [[FETCH]]:

      :   `url`
      ::  |endpoint|'s {{endpoint/url}}
      :   `header list`
      ::  A new <a>header list</a> containing a <a>header</a> named
          "`Content-Type`" whose value is "`application/report`"
      :   `client`
      ::  `null`
      :   `window`
      ::  "`no-window`"
      :   `skip-service-worker` flag
      ::  Set.
      :   `initiator`
      ::  ""
      :   `type`
      ::  "`report`"
      :   `destination`
      ::  ""
      :   `mode`
      ::  "`cors`"
      :   `credentials`
      ::  "`include`"
      :   `body`
      ::  The string resulting from executing the {{JSON.stringify()}} algorithm
          on |collection| [[!ECMA-262]]

      ISSUE: The "`report`" type does not exist in Fetch. Talk to Anne.

  4.  User agent MAY choose to alter |request| in order to send |report| to a
      different endpoint.

  Note: The intended use case for allowing reports to be sent to a different
  endpoint is so that reports containing sensitive information (either for
  security or privacy reasons) can be aggregated and anonymized at a third party
  server before being delivered to the originally intended |endpoint|. For this
  use case, the original |endpoint|'s {{endpoint/url}} should be included with
  the |request|, and the eventually sent aggregated report should have
  the <a>report type</a> of |report|'s <a>report type</a>'s <a>aggregated
  type</a>.

  5.  <a>Queue a task</a> to <a>fetch</a> |request|.

  6.  <a>Wait for a response</a> (|response|).

  7.  If |response|'s `status` is an <a>OK status</a> (200-299), return
      "`Success`".

  8.  If |response|'s `status` is `410 Gone` [[!RFC7231]], return "`Remove
      Endpoint`".

  9.  Return "`Failure`".
</section>

<section>
  <h2 id="observers">Reporting Observers</h2>

  A <dfn>reporting observer</dfn> observes some types of <a>reports</a> from
  JavaScript, and is represented in JavaScript by the {{ReportingObserver}}
  object.

  Each <a spec=ecmascript lt=realm>ECMAScript global environment</a> has
  a <dfn>registered reporting observer list</dfn>, which is an <a>ordered
  set</a> of <a>reporting observers</a>.

  Any <a>reporting observer</a> that is in a <a>registered reporting observer
  list</a> is considered <dfn>registered</dfn>.

  Each <a spec=ecmascript lt=realm>ECMAScript global environment</a> has
  a <dfn>report buffer</dfn>, which is a <a spec=infra>list</a>
  of <a>reports</a> that have been generated in that <a spec=ecmascript
  lt=realm>ECMAScript global environment</a>. This list is initially empty, and
  the reports are stored in the same order in which they are generated.

  Note: The purpose of the <a>report buffer</a> is to allow <a>reporting
  observers</a> to observe reports that were generated earlier than that
  observer could be created (via the {{buffered}} option). For example, some
  reports might be generated during an earlier stage of page loading than when
  an observer could first be created, or before a JavaScript library is loaded
  that wishes to observe these reports.

  Note: </a>Reporting observers</a> are only relevant for user agents with
  JavaScript engines.

  <h3 id=interface-reporting-observer>Interface {{ReportingObserver}}</h3>

  <pre class="idl">
interface ReportBody {
};

interface Report {
  readonly attribute DOMString type;
  readonly attribute DOMString url;
  readonly attribute ReportBody? body;
};

[Constructor(ReportingObserverCallback callback, optional ReportingObserverOptions options)]
interface ReportingObserver {
  void observe();
  void disconnect();
  ReportList takeRecords();
};

callback ReportingObserverCallback = void (sequence&lt;Report> reports, ReportingObserver observer);

dictionary ReportingObserverOptions {
  sequence&lt;DOMString> types;
  boolean buffered = true;
};

typedef sequence&lt;Report> ReportList;
  </pre>

  A <dfn id=dom-report interface>Report</dfn> is the application exposed
  representation of a <a>report</a>. <dfn attribute for="Report">type</dfn>
  returns [=report/type=], <dfn attribute for="Report">url</dfn> returns
  [=report/url=], and <dfn attribute for="Report">body</dfn> returns
  [=report/body=].

  Each {{ReportingObserver}} object has these associated concepts:
    - A <dfn for=ReportingObserver>callback</dfn> function set on creation.
    - A {{ReportingObserverOptions}} dictionary called
      <dfn for=ReportingObserver>options</dfn>.
    - A list of {{Report}} objects called the <dfn for=ReportingObserver>report
      list</dfn>, which is initially empty.

  A {{ReportList}} represents a sequence of {{Report}}s, providing developers
  with all the convenience methods found on JavaScript arrays.

  The <dfn constructor for=ReportingObserver><code>
  ReportingObserver(|callback|, |options|)</code></dfn> constructor, when invoked, must run
  these steps:

  1. Create a new {{ReportingObserver}} object |observer|.

  2. Set |observer|'s <a>callback</a> to |callback|.

  3. Set |observer|'s <a>options</a> to |options|.

  4. Return |observer|.

  The <dfn method for=ReportingObserver><code>observe()</code></dfn>
  method, when invoked, must run these steps:

  1. Let |environment| be the <a spec=ecmascript lt=realm>ECMAScript global environment</a> associated with
     the <a>context object</a>.

  2. Append the <a>context object</a> to the <a>registered reporting observer
     list</a> of its associated <a spec=ecmascript lt=realm>ECMAScript global environment</a>.

  3. If the <a>context object</a>'s {{buffered}} <a>option</a> is false, return.

  4. Set <a>context object</a>'s {{buffered}} <a>option</a> to false.

  5. For each |report| in the <a>report buffer</a> associated with |environment|,
     execute [[#add-report]] with |report| and the <a>context object</a>.

  The <dfn method for=ReportingObserver><code>disconnect()</code></dfn> method,
  when invoked, must run these steps:

  1. If the <a>context object</a> is not <a>registered</a>, return.

  2. Remove the <a>context object</a> from the <a>registered reporting observer
     list</a> of its associated <a spec=ecmascript lt=realm>ECMAScript global environment</a>.

  The <dfn method for=ReportingObserver><code>takeRecords()</code></dfn> method,
  when invoked, must run these steps:

  1. Let |reports| be a copy of the <a>context object</a>'s <a>report list</a>.

  2. Empty the <a>context object</a>'s <a>report list</a>.

  3. Return |reports|.

  <h3 id="notify-observers" algorithm>
    Notify reporting observers on |environment| with |report|
  </h3>

  This algorithm makes |report|'s contents available to any <a>registered</a>
  <a>reporting observers</a> on the provided <a spec=ecmascript lt=realm>ECMAScript global environment</a>
  |environment|.

  1. For each {{ReportingObserver}} |observer| <a>registered</a> with
     |environment|, execute [[#add-report]] on |report| and |observer|.

  2. Append |report| to the <a>report buffer</a> associated with |environment|.

  3. If the <a>report buffer</a> now contains more than 100 reports, remove the
     item at the beginning of the <a>report buffer</a>.

  <h3 id="add-report" algorithm>
    Add |report| to |observer|
  </h3>

  Given a <a>report</a> |report| and a {{ReportingObserver}} |observer|, this
  algorithm adds |report| to |observer|'s <a>report list</a>, so long as
  |report|'s <a>type</a> is observable by |observer|.

  1. If |report|'s [=report/type=] is not <a>observable from JavaScript</a>,
     return.

  2. If |observer|'s <a>options</a> has a {{ReportingObserverOptions/types}}
     member which does not contain |report|'s [=report/type=], return.

  3. Create a new {{Report}} |r| with {{Report/type}} initialized to |report|'s
     [=report/type=], {{Report/url}} initialized to |report|'s [=report/url=],
     and {{Report/body}} initialized to |report|'s [=report/body=].

  Issue: how to polymorphically initialize body?

  3. Append |r| to |observer|'s <a>report list</a>.

  4. If the size of |observer|'s <a>report list</a> is 1, <a>Queue a task</a> to
     [[#invoke-observers]] with a copy of the <a>registered reporting observer
     list</a> of the <a spec=ecmascript lt=realm>ECMAScript global environment</a> associated with
     |observer|.

  <h3 id="invoke-observers" algorthm>
    Invoke reporting observers with |notify list|
  </h3>

  This algorithm invokes observer callback functions for reports of previously
  observed behavior.

  1. For each {{ReportingObserver}} |observer| in |notify list|:

     1. If |observer|'s <a>report list</a> is empty, then continue.

     2. Let |reports| be a copy of |observer|'s <a>report list</a>

     3. Empty |observer|'s <a>report list</a>

     4. <a spec=webidl>Invoke</a> |observer|'s <a>callback</a> with a list of
        arguments consisting of |reports| and |observer|, and |observer| as the
        <a>callback this value</a>.  If this throws an exception, <a>report the
        exception</a>.
</section>

<section>
  <h2 id="report-types">Report Types</h2>

  <h3 id="deprecation-report">Deprecation</h3>

  Deprecation reports indicate that a browser API or feature has been used which
  is expected to stop working in a future update to the browser.

  Deprecation reports have the <a>report type</a> "deprecation".

  A deprecation report's [=report/body=] contains the following fields:

    - <dfn for="Deprecation">id</dfn>: an implementation-defined string
      identifying the feature or API that will be removed. This string can be used
      for grouping and counting related reports.

    - <dfn for="Deprecation">anticipatedRemoval</dfn>: A date indicating roughly
      when the browser version without the specified API will be generally
      available (excluding "beta" or other pre-release channels). This value
      should be used to sort or prioritize warnings. If unknown, this field
      should be set to null, and the deprecation should be considered low
      priority (removal may not actually occur).

    - <dfn for="Deprecation">message</dfn>: A human-readable string with
      details typically matching what would be displayed on the developer
      console. The message is not guaranteed to be unique for a given
      [=Deprecation/id=] (eg. it may contain additional context on how the API
      was used).

    - <dfn for="Deprecation">sourceFile</dfn>: If known, the file which first
      used the indicated API, or null otherwise.

    - <dfn for="Deprecation">lineNumber</dfn>: If known, the line number in
      [=Deprecation/sourceFile=] where the indicated API was first used, or null
      otherwise.

    - <dfn for="Deprecation">columnNumber</dfn>: If known, the column number in
      [=Deprecation/sourceFile=] where the indicated API was first used, or null
      otherwise.

  Deprecation reports are <a>observable from JavaScript</a>.

</section>

<section>
  <h2 id="implementation">Implementation Considerations</h2>

  <h3 id="delivery">Delivery</h3>

  The user agent SHOULD attempt to deliver reports as soon as possible to
  provide feedback to developers as quickly as possible. However, when this
  desire is balanced against the impact on the user, the user wins. With that
  in mind, the user agent MAY delay delivery of reports based on its knowledge
  of the user's activities and context.

  For instance, the user agent SHOULD prioritize the transmission of reporting
  data lower than other network traffic. The user's explicit activities on a
  website should preempt reporting traffic.

  The user agent MAY choose to withhold report delivery entirely until the user
  is on a fast, cheap network in order to prevent unnecessary data cost.

  The user agent MAY choose to prioritize reports from particular origins over
  others (perhaps those that the user visits most often?)

  <h3 id="gc">Garbage Collection</h3>

  Periodically, the user agent SHOULD walk through the cached <a>reports</a>
  and <a>endpoints</a>, and discard those that are no longer relevant. These
  include:

  *   <a>endpoint groups</a> which are <a for="endpoint group">expired</a>
  *   <a>endpoint groups</a> which have not been used in some arbitrary period
      of time (perhaps a ~week?)
  *   <a>endpoints</a> whose {{endpoint/failures}} exceed
      some user-agent-defined threshold (~5 seems reasonable)
  *   <a>reports</a> whose [=report/attempts=] exceed
      some user-agent-defined threshold (~5 seems reasonable)
  *   <a>reports</a> which have not been delivered in some arbitrary period of
      time (perhaps ~2 days?)

  For any <a>reports</a> that are discarded, these <a>reports</a> should also be
  removed from the <a>report buffer</a> of any <a>reporting observer</a>.
</section>

<section>
  <h2 id="sample-reports">Sample Reports</h2>

  <div class="example">
    <pre>
      POST / HTTP/1.1
      Host: example.com
      ...
      Content-Type: application/report

      [{
        "type": "csp",
        "age": 10,
        "url": "https://example.com/vulnerable-page/",
        "body": {
          "blocked": "https://evil.com/evil.js",
          "directive": "script-src",
          "policy": "script-src 'self'; object-src 'none'",
          "status": 200,
          "referrer": "https://evil.com/"
        }
      }, {
        "type": "hpkp",
        "age": 32,
        "url": "https://www.example.com/",
        "body": {
          "date-time": "2014-04-06T13:00:50Z",
          "hostname": "www.example.com",
          "port": 443,
          "effective-expiration-date": "2014-05-01T12:40:50Z"
          "include-subdomains": false,
          "served-certificate-chain": [
            "-----BEGIN CERTIFICATE-----\n
            MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\n
            ...
            HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\n
            WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\n
            yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\n
            -----END CERTIFICATE-----",
            ...
          ]
        }
      }, {
        "type": "nel",
        "age": 29,
        "url": "https://example.com/thing.js",
        "body": {
          "referrer": "https://www.example.com/",
          "server-ip": "234.233.232.231",
          "protocol": "",
          "status-code": 0,
          "elapsed-time": 143,
          "age": 0,
          "type": "http.dns.name_not_resolved"
        }
      }]
    </pre>
  </div>
</section>

<section>
  <h2 id="security">Security Considerations</h2>

  <h3 id="capability-urls">Capability URLs</h3>

  Some URLs are valuable in and of themselves. To mitigate the possibility
  that such URLs will be leaked via this reporting mechanism, we strip out
  credential information and fragment data from the URL we store as a
  <a>report</a>'s originator. It is still possible, however, for a feature
  to unintentionally leak such data via a report's [=report/body=]. Implementers
  SHOULD ensure that URLs contained in a report's body are similarly stripped.
</section>

<section>
  <h2 id="privacy">Privacy Considerations</h2>

  <h3 id="network-leakage">Network Leakage</h3>

  Because this reporting mechanism is out-of-band, and doesn't rely on a page
  being open, it's entirely possible for a report generated while a user is on
  one network to be sent while the user is on another network, even if they
  don't explicitly open the page from which the report was sent.

  ISSUE(WICG/BackgroundSync#107): Consider mitigations. For example, we could
  drop reports if we change from one network to another.

  <h3 id="fingerprinting-clock-skew">Clock Skew</h3>

  Each report is delivered along with an `age` property, rather than the
  timestamp at which it was generated. We do this because each user's local
  clock will be skewed from the clock on the server by an arbitrary amount.
  The difference between the time the report was generated and the time it
  was sent will be stable, regardless of clock skew, and we can avoid the
  fingerprinting risk of exposing the clock skew via this API.

  <h3 id="correlation">Cross-origin correlation</h3>

  If multiple origins all use the same reporting endpoint, that endpoint may
  learn that a particular user has interacted with a certain set of websites,
  as it will receive origin-tagged reports from each. This doesn't seem worse
  than the status quo ability to track the same information from cooperative
  origins, and doesn't grant any new tracking ability above and beyond what's
  possible with `<img>` today.

  <h3 id="subdomains">Subdomains</h3>

  This specification allows any resource on a host to declare a set of reporting
  endpoints for that host and each of its subdomains. This doesn't have privacy
  implications in and of itself (beyond those noted in [[#clear-cache]]), as the
  reporting endpoints themselves don't take any real action, as features will
  need to opt-into using these reporting endpoints explicitly. Those features
  certainly will have privacy implications, and should carefully consider
  whether they should be enabled across origin boundaries.

  <h3 id="clear-cache">Clearing the reporting cache</h3>

  A user agent's <a>reporting cache</a> contains data about a user's activity
  on the web, and user agents ought to handle this data carefully. In
  particular, if a user agent gives users the ability to clear their site data,
  browsing history, browsing cache, or similar, the user agent MUST also clear
  the <a>reporting cache</a>. Note that this includes both the pending reports
  themselves, as well as the endpoints to which they would be sent. Both MUST
  be cleared.

  <h3 id="disable">Disabling Reporting</h3>

  Reporting is, to some extent, a question of commons. In the aggregate, it
  seems useful for everyone for reports to be delivered. There is direct benefit
  to developers, as they can fix bugs, which means there's indirect benefit to
  users, as the sites they enjoy will be more stable and enjoyable. As a
  concrete example, Content Security Policy grants something like herd immunity
  to cross-site scripting attacks by alerting developers about potential holes
  in their sites' defenses. Fixing those bugs helps every user, even those whose
  user agents don't support Content Security Policy.

  The calculus, of course, depends on the nature of data that's being delivered,
  and the relative maliciousness of the reporting endpoints, but that's the
  value proposition in broad strokes.

  That said, it can't be the case that this general benefit be allowed to take
  priority over the ability of a user to individually opt-out of such a system.
  Sending reports costs bandwidth, and potentially could reveal some small
  amount of additional information above and beyond what a website can obtain
  in-band ([[NETWORK-ERROR-LOGGING]], for instance). User agents MUST allow
  users to disable reporting with some reasonable amount of granularity in order
  to maintain the priority of constituencies espoused in
  [[HTML-DESIGN-PRINCIPLES]].
</section>

<!-- Big Text: IANA -->
<section>
  <h2 id="iana-considerations">IANA Considerations</h2>

  The permanent message header field registry should be updated
  with the following registration: [[!RFC3864]]

  <h3 id="iana-report-to">
    Report-To
  </h3>

  :   Header field name
  ::  `Report-To`
  :   Applicable protocol
  ::  http
  :   Status
  ::  standard
  :   Author/Change controller
  ::  W3C
  :   Specification document
  ::  This specification (see [[#header]])
</section>
